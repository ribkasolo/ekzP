--Билет 8
--Создать таблицу "Клиенты месяца" и заполнить ее  клиентами,  
--которые сделали заказы в апреле текущего года. 
CREATE TABLE Клиенты_месяца (
    Код_клиента INT PRIMARY KEY,
    название NVARCHAR(50)
);

INSERT INTO Клиенты_месяца (Код_клиента, название)
SELECT DISTINCT клиенты.Код_клиента, клиенты.название
FROM клиенты
JOIN заказы ON заказы.Клиент = клиенты.Код_клиента
WHERE MONTH(заказы.дата_выполнения) = 4

--Билет 10
--Создать таблицу "Клиенты месяца" и заполнить ее  клиентами,  
--которые сделали заказы в текущем месяце текущего года. 
CREATE TABLE Клиенты_месяца (
    Код_клиента INT PRIMARY KEY,
    название NVARCHAR(50)
);
INSERT INTO Клиенты_месяца (Код_клиента, название)
SELECT DISTINCT клиенты.Код_клиента, клиенты.название
FROM клиенты
JOIN заказы ON заказы.Клиент = клиенты.Код_клиента
WHERE MONTH(заказы.дата_выполнения) = MONTH(GETDATE())
  AND YEAR(заказы.дата_выполнения) = YEAR(GETDATE());

--Билет 9
--У сотрудника с кодом 11 изменился телефон. Новый номер его мобильного 89137895465.
UPDATE телефоны
SET телефон='89137895465'
--FROM сотрудники JOIN телефоны ON телефон.сотрудник=сотрудники.Код_сотрудника
WHERE сотрудник =  11 

--Билет 11
--У сотрудника Долгих остался только рабочий телефон.

-- Сначала получим Код_сотрудника для Долгих
DECLARE @КодСотрудника INT;
SELECT @КодСотрудника = Код_сотрудника
FROM сотрудники
WHERE фамилия = 'Долгих';

-- Удаляем все телефоны, кроме рабочего
DELETE FROM Телефоны
WHERE сотрудник = @КодСотрудника
AND тип <> (SELECT Код_типа FROM тип_тел WHERE тип = 'Рабочий');

--Билет 12
--Создайте хранимую процедуру «ДетиСотрудников», 
--при выполнении которой будет выводиться следующая информация
CREATE PROCEDURE ДетиСотрудников
AS
BEGIN
    -- Выбор информации о детях сотрудников
    SELECT 
        ребенок.Код_ребенка,
        ребенок.Фамилия,
        ребенок.Имя,
        ребенок.дата_рожд,
        сотрудники.Код_сотрудника,
        сотрудники.фамилия + ' ' + сотрудники.Имя + ' ' + сотрудники.Отчество AS Сотрудник
    FROM ребенок
    JOIN сотрудники ON ребенок.Код_сотрудника = сотрудники.Код_сотрудника;
END;

--Билет 13
--Создайте хранимую процедуру «ДетиСотрудника», при выполнении которой 
--будет выводиться дети указанного пользователем сотрудника.
CREATE PROCEDURE ДетиСотрудника
    @Код_сотрудника INT
AS
BEGIN
    SELECT Код_ребенка, Фамилия, Имя
    FROM дети
    WHERE сотрудник = @Код_сотрудника;
END;
--Вызов процедуры
EXEC ДетиСотрудника @Код_сотрудника = 2;

--Билет 14
--Создайте функцию “KolTov”, которая производит 
--расчет общего количества проданного товара «Кока-кола».
CREATE FUNCTION KolTov()
RETURNS INT
AS
BEGIN
    DECLARE @TotalQuantity INT;

    SELECT @TotalQuantity = SUM(Количество)
    FROM товары
    WHERE Код_товара IN (
        SELECT Код_товара
        FROM товары
        WHERE наименование = 'Кока-кола'
    );

    RETURN COALESCE(@TotalQuantity, 0); -- Возвращаем 0, если результат NULL
END;
--Вызов процедуры
SELECT dbo.KolTov() AS ОбщееКоличествоПроданногоКокаКола;

--Билет 15
--Создайте функцию “KolZak”, которая позволяет 
--по каждому товару вывести информацию об общем количестве заказов на него за апрель.
CREATE FUNCTION KolZak()
RETURNS TABLE
AS
RETURN
(
    SELECT 
        товары.Код_товара,
        товары.наименование,
        SUM(заказы.количество) AS ОбщееКоличествоЗаказов
    FROM 
		товары LEFT JOIN заказы ON товары.Код_товара = заказы.код_товара
    WHERE 
        MONTH(заказы.дата_выполнения) = 4  -- Апрель
        --AND YEAR(заказы.дата_выполнения) = YEAR(GETDATE())  -- Текущий год (можно изменить на нужный год)
    GROUP BY товары.Код_товара, товары.наименование
);
--Вызов процедуры
SELECT * FROM KolZak();

--Билет 16
--Создайте триггер “InsGr”, который будет вызваться при вставке данных
--в таблицу Группы и выводить сообщение «Добавлена новая группа».
CREATE TRIGGER InsGr
ON группы
AFTER INSERT
AS
BEGIN
    PRINT 'Добавлена новая группа'
END;
--Проверка триггера
INSERT INTO группы (Код_группы, группа)
VALUES (12, 'Новая группа');

--Билет 17
--Создайте триггер “DelDeti”, который при удалении данных из таблицы «Дети» 
--будет выводить сообщение «Удалять нельзя!» и данные в таблице оставит неизменными.
CREATE TRIGGER DelDeti
ON Дети
INSTEAD OF DELETE
AS
BEGIN
    PRINT 'Удалять нельзя!'
END;
--Проверка триггера
DELETE FROM Дети WHERE Код_ребенка = 1;

--Билет 18
--Создайте триггер “UpTov”, который при изменении данных в таблице «Товары»
--занесет исходную информацию в таблицу «ТоварыИзменения». 
--В таблице «ТоварыИзменения» должна быть указана дата изменения товара.
CREATE TABLE [dbo].[ТоварыИзменения] (
    [Код_товара] INT,
    [наименование] NVARCHAR(100),
    [группа] NVARCHAR(100),
    [единица] NVARCHAR(50),
    [вес] DECIMAL(18, 2),
    [цена] DECIMAL(18, 2),
    [количество] INT,
    [дата_изменения] DATETIME
);
CREATE TRIGGER UpTov
ON Товары
AFTER UPDATE
AS
BEGIN
    INSERT INTO ТоварыИзменения ([Код_товара], [наименование], [группа], [единица], [вес], [цена], [количество], [дата_изменения])
    SELECT 
        i.[Код_товара],
        i.[наименование],
        i.[группа],
        i.[единица],
        i.[вес],
        i.[цена],
        i.[количество],
        GETDATE() -- Получение текущей даты и времени
    FROM 
        inserted i; -- Используем таблицу inserted для получения измененных данных
END;

--Проверка триггера
UPDATE Товары
SET [цена] = [цена] * 1.1 -- Например, увеличение цены на 10%
WHERE Код_товара = 1;

--Билет 19
--Создайте триггер “DelTel”, который при удалении данных из таблицы «Телефоны»
--будет выводить сообщение «Удалять нельзя!» и данные в таблице оставит неизменными.
CREATE TRIGGER DelTel
ON Телефоны
INSTEAD OF DELETE
AS
BEGIN
    PRINT 'Удалять нельзя!'
END;
--Проверка триггера
DELETE FROM Телефоны WHERE Код_телефона = 1;

--Билет 20
--Сотрудник Фролова В.С. была принята на постоянную работу. 
--Измените условия найма в таблице Сотрудники с учетом этих условий

-- 1. Определяем код условия найма для постоянной работы
DECLARE @PermanentCondition INT;
SELECT @PermanentCondition = Код_найма
FROM Найм
WHERE условие = 'постоянно';

-- 2. Обновляем условие найма для сотрудника Фролова
UPDATE Сотрудники
SET условие = @PermanentCondition
WHERE фамилия = 'Фролова'
  AND Имя = 'Вероника'
  AND Отчество = 'Станиславовна';

-- Проверка: выводим изменённые данные
SELECT * FROM Сотрудники
WHERE фамилия = 'Фролова' AND Имя = 'Вероника' AND Отчество = 'Станиславовна';

--Билет 21 ?
--Создайте триггер “UpTov”, который при изменении данных в таблице «Товары» 
--занесет исходную информацию в таблицу «ТоварыИзменения». 
--В таблице «ТоварыИзменения» должна быть указана дата изменения товара.
CREATE TABLE ТоварыИзменения (
    Код_товара INT,
    Название VARCHAR(255),
    Цена DECIMAL(18, 2),
    Количество INT,
    Дата_изменения DATETIME
);

CREATE TRIGGER UpTov
ON Товары
AFTER UPDATE
AS
BEGIN
    -- Вставляем измененные данные в таблицу ТоварыИзменения
    INSERT INTO ТоварыИзменения (Код_товара, наименование, группа, единица, вес, цена, количество, дата_изменения)
    SELECT 
        Товары.Код_товара,
        Товары.наименование,
        Товары.группа,
        Товары.единица,
        Товары.вес,
        Товары.цена,
        Товары.количество,
        GETDATE() AS дата_изменения  -- Текущая дата и время
    FROM 
        inserted AS i
    JOIN 
        Товары ON i.[Код_товара] = Товары.[Код_товара];
END;

-- Пример обновления товара
UPDATE Товары
SET Цена = 200.00, Количество = 50
WHERE Код_товара = 1;
-- Проверка таблицы ТоварыИзменения
SELECT * FROM ТоварыИзменения;

--Билет 22
--В таблицу «Товары» с помощью языка T-SQL добавить следующие записи: 
INSERT INTO Товары (Код_товара, наименование, группа, единица, вес, цена, количество)
VALUES 
(21, 'печенье "Мария"', 5, 3, 0.1, 250, 35),
(22, 'кекс Клубничный', 5, 1, 0.2, 100, 12),
(23, 'Гринфилд', 1, 3, 0.25, 120, 80),
(24, 'Цитрусовый', 1, 3, 0.1, 110, 5);
--Проверка
SELECT *
FROM Товары;

--Билет 23
--Создайте хранимую процедуру при выполнении которой 
--выводится информация о товарах, расфасованных в банки.
DROP PROCEDURE ТоварыБанка;
CREATE PROCEDURE ТоварыБанка
AS
BEGIN
    SET NOCOUNT ON;

    SELECT *
    FROM единицы
	JOIN товары ON единицы.Код_единицы = товары.единица
    --WHERE единицы.единица = 'банка, жесть' or единицы.единица = 'банка, стекло';
	WHERE единицы.единица LIKE '%банка%';
END;
--Проверка
EXEC ТоварыБанка;

--Билет 24 ?
--Создайте пользовательскую функцию, которая производит расчет 
--суммы всех заказов клиента ООО "Рога и копыта" за март текущего года.

--DROP FUNCTION dbo.СуммаЗаказов; для удаления, если ошибка

CREATE FUNCTION dbo.СуммаЗаказов()
RETURNS DECIMAL(18, 2)
AS
BEGIN
    DECLARE @TotalSum DECIMAL(18, 2);
    DECLARE @ClientCode INT;

    -- Получаем код клиента "ООО Рога и копыта"
    SELECT @ClientCode = Код_клиента 
    FROM Клиенты 
    WHERE Название = 'ООО Рога и копыта';

    -- Рассчитываем сумму всех заказов для клиента
    SELECT @TotalSum = SUM(заказы.количество * товары.цена)
    FROM заказы
    JOIN товары ON заказы.код_товара = товары.Код_товара
    WHERE заказы.клиент = @ClientCode
      AND MONTH(заказы.дата_размещения_заказа) = 3;  -- Март

    -- Если не найдено, возвращаем 0
    IF @TotalSum IS NULL
        SET @TotalSum = 0;

    RETURN @TotalSum;
END;
--Проверка функции
SELECT dbo.СуммаЗаказов() AS TotalSum;

SELECT DISTINCT клиент
FROM заказы;

--Билет 25 ?
--Создайте представление, которое выводит информацию 
--о количестве заказов клиента ООО "Рога и копыта" за текущий год.
CREATE VIEW dbo.КоличествоЗаказовРогаКопыта AS
SELECT COUNT(Заказы.Код_заказа) AS Количество_заказов
FROM Заказы
JOIN Клиенты ON Заказы.клиент = Клиенты.Код_клиента
WHERE Клиенты.название = 'ООО Рога и копыта'
  AND YEAR(Заказы.дата_выполнения) = YEAR(GETDATE());

--Билет 26
--Создайте триггер InsDety для таблицы Дети, который вызывается после добавления нового ребенка. 
--В результате выполнения триггера должно выводиться сообщение «Добавлен новый элемент».
CREATE TRIGGER InsDety
ON Дети
AFTER INSERT
AS
BEGIN
    PRINT 'Добавлен новый элемент';
END;
--Проверка
INSERT INTO Дети (сотрудник, фамилия, имя, отчество, пол, дата_рожд)
VALUES ('Иванов И.И.', 'Иванов', 'Иван', 'Иванович', 'М', '2023-01-01');

--Билет 27
--У клиента ЗАО "Дебют" изменился адрес. Новый адрес улица Куйбышева, дом 15. 
UPDATE Клиенты
SET улица = 'Куйбышева', дом = '15'
WHERE название = 'ЗАО "Дебют"';
--Проверка
SELECT *
FROM Клиенты
WHERE название = 'ЗАО "Дебют"';

--Билет 28 
DELETE FROM телефоны
WHERE телефон = '3812445230'
AND сотрудник = (
    SELECT Код_сотрудника
    FROM сотрудники
    WHERE фамилия = 'Иванов' 
    AND Имя = 'И.И.' -- посмотреть и внести полное имя и отчество
);

--Проверка
SELECT *
FROM телефоны
WHERE телефон = '3812445230'
AND сотрудник = (
    SELECT Код_сотрудника
    FROM сотрудники
    WHERE фамилия = 'Иванов' 
    AND Имя = 'И.И.' -- посмотреть и внести полное имя и отчество
);